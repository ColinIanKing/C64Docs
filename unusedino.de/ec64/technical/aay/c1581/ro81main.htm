<html><head><title>All_About_Your_1581-Online-Help Version 0.13</title></head>
<body bgcolor="#a098ff" text="#000000" link="#ffffff" alink="#ffffff" vlink="#404040"><center><table><tr><td><pre>

  +------------------------------------------------------------------------
  |
  |      DISK-DRIVE 1581: ROM-LISTING
  |
  +------------------------------------------------------------------------
  |
  | Comments done by Peter Steiner, used with permission.
  |
  |   <a href="ro818000.htm">$8000/32768</a>      Checksumme
  |   <a href="ro818004.htm">$8004/32772</a>      Befehlsstring vom Computer auswerten ($c146)
  |   <a href="ro81804c.htm">$804C/32844</a>      Abschluss eines Befehls ($c194)
  |   <a href="ro818071.htm">$8071/32881</a>      INPUT-Puffer loeschen ($c1bd)
  |   <a href="ro81807c.htm">$807C/32892</a>      Fehler ausgeben mit T&amp;S = 00 ($c1c8)
  |   <a href="ro818085.htm">$8085/32901</a>      Sucht Drivenummer in der Befehlszeile ($c1d1)
  |   <a href="ro818099.htm">$8099/32921</a>      Eingabezeile bis zum ':' auswerten ($c1e5)
  |   <a href="ro8180a2.htm">$80A2/32930</a>      Eingabezeile pruefen bei Copy, Rename, New ($c1ee)
  |   <a href="ro81811c.htm">$811C/33052</a>      Eingabezeile bis zu einem bestimmten Zeichen auswerten ($c268)
  |   <a href="ro818165.htm">$8165/33125</a>      Kommandozeilenende feststellen (CR (/LF) entfernen) ($c2b3)
  |   <a href="ro8181e5.htm">$81E5/33253</a>      LED-Routinen ($c100)
  |   <a href="ro8181fd.htm">$81FD/33277</a>      Laufwerksnummer holen und setzen ($c312)
  |   <a href="ro81820b.htm">$820B/33291</a>      Alle Parameter auf Laufwerksnummer pruefen und diese ggf. loeschen ($c320)
  |   <a href="ro818224.htm">$8224/33316</a>      Laufwerksnummer testen und entfernen ($c33c)
  |   <a href="ro818251.htm">$8251/33361</a>      Drivenummer setzen, LED einschalten ($c368)
  |   <a href="ro818270.htm">$8270/33392</a>      Dateityp feststellen ('s,p,u,r,c') (z.B. '$*=s') ($c398)
  |   <a href="ro818295.htm">$8295/33429</a>      Laufwerksnummer pruefen ($c3bd)
  |   <a href="ro8182a2.htm">$82A2/33442</a>      Drive initialisieren, LED einschalten ($c3ca)
  |   <a href="ro8182b9.htm">$82B9/33465</a>      alle angegebenen Dateien im Directory suchen ($c44f)
  |   <a href="ro8182e6.htm">$82E6/33510</a>      Dateien einzeln suchen ($c48b)
  |   <a href="ro818327.htm">$8327/33575</a>      Eintrag im Directory mit gesuchten Eintraegen vergleichen ($c4d8)
  |   <a href="ro8183d7.htm">$83D7/33751</a>      Prueft, ob alle Dateien gefunden worden sind ($c617)
  |   <a href="ro8183fa.htm">$83FA/33786</a>      1581: Zeichen hinter '*' vergleichen
  |   <a href="ro818424.htm">$8424/33828</a>      naechsten Eintrag im Directory suchen : ($c5ac)
  |   <a href="ro8184ae.htm">$84AE/33966</a>      Testet auf Diskettenwechsel und initialisiert ggf. ($c63d)
  |   <a href="ro8184ee.htm">$84EE/34030</a>      Parameter aus dem INPUT-Puffer in Disk-Puffer kopieren ($c66e)
  |   <a href="ro818526.htm">$8526/34086</a>      Laenge eines Parameters ermitteln ($c6a6)
  |   <a href="ro81854d.htm">$854D/34125</a>      Directory-Zeile im Zwischenpuffer erzeugen ($c6ce)
  |   <a href="ro818688.htm">$8688/34440</a>      Scratch ($c823)
  |   <a href="ro818746.htm">$8746/34630</a>      Partition formatieren
  |   <a href="ro81876e.htm">$876E/34670</a>      Copy ($c8f0)
  |   <a href="ro818841.htm">$8841/34881</a>      aktuelles File oeffnen ($c9fa)
  |   <a href="ro818876.htm">$8876/34934</a>      Byte aus aktueller Datei holen und auf Dateiende pruefen ($ca35)
  |   <a href="ro818895.htm">$8895/34965</a>      REL-File zum Kopieren vorbereiten ($ca53)
  |   <a href="ro8188c5.htm">$88C5/35013</a>      RENAME ($ca88)
  |   <a href="ro818903.htm">$8903/35075</a>      aktuellen Filetyp ermitteln und
  |   <a href="ro81891e.htm">$891E/35102</a>      pruefen, ob alle Files vor dem '=' nicht existieren
  |   <a href="ro81892f.htm">$892F/35119</a>      Memory-Befehle ($caf8)
  |   <a href="ro81898f.htm">$898F/35215</a>      User-Befehle ($cb5c)
  |   <a href="ro8189e4.htm">$89E4/35300</a>      '#', oeffnen eines Direktzugriffkanals ($cb84)
  |   <a href="ro818a5d.htm">$8A5D/35421</a>      Block-Befehle ($cc1b)
  |   <a href="ro818a9f.htm">$8A9F/35487</a>      Parameter der Block-Befehle holen ($cc7c)
  |   <a href="ro818ad0.htm">$8AD0/35536</a>      ASCII-Werte aus dem Input-Puffer in HEX-Werte umwandeln
  |   <a href="ro818b23.htm">$8B23/35619</a>      Block-Free ($ccf5)
  |   <a href="ro818b2f.htm">$8B2F/35631</a>      Block-Allocate ($cd03)
  |   <a href="ro818b65.htm">$8B65/35685</a>      Block-Read-Parameter pruefen und Block lesen ($cd36)
  |   <a href="ro818b6b.htm">$8B6B/35691</a>      Byte aus Puffer holen ($cd3c)
  |   <a href="ro818b71.htm">$8B71/35697</a>      Block lesen und Pufferzeiger setzen ($cd42)
  |   <a href="ro818b85.htm">$8B85/35717</a>      Block-Read ($cd56)
  |   <a href="ro818b8e.htm">$8B8E/35726</a>      Super-Read
  |   <a href="ro818b9a.htm">$8B9A/35738</a>      u1 ($cd5f)
  |   <a href="ro818bae.htm">$8BAE/35758</a>      Block-Write ($cd73)
  |   <a href="ro818bd1.htm">$8BD1/35793</a>      Super-Write
  |   <a href="ro818bd7.htm">$8BD7/35799</a>      u2 ($cd97)
  |   <a href="ro818be3.htm">$8BE3/35811</a>      Block-Execute ($cda3)
  |   <a href="ro818bfa.htm">$8BFA/35834</a>      Block-Pointer ($cdbd)
  |   <a href="ro818c0f.htm">$8C0F/35855</a>      Kanal oeffnen ($cdd2)
  |   <a href="ro818c2f.htm">$8C2F/35887</a>      Kanal oeffnen, Blockparameter holen und testen ($cdf2)
  |   <a href="ro818c44.htm">$8C44/35908</a>      Kanal oeffnen, Blockparameter holen und NICHT testen
  |   <a href="ro818c5c.htm">$8C5C/35932</a>      Puffer allokieren
  |   <a href="ro818c61.htm">$8C61/35937</a>      Block-Befehle und Adressen ($cc5d)
  |   <a href="ro818c89.htm">$8C89/35977</a>      Position des Records berechnen ($ce0e)
  |   <a href="ro818cc1.htm">$8CC1/36033</a>      Zahl der Bytes bis zum gesuchten Record berechnen ($ce2c)
  |   <a href="ro818ce6.htm">$8CE6/36070</a>      24*8-Bit-Multiplikationsroutine ($ce4e)
  |   <a href="ro818d06.htm">$8D06/36102</a>      24/8-Bit-Divisionsroutine ($ce71)
  |   <a href="ro818d38.htm">$8D38/36152</a>      Rechenregister 1 loeschen ($ced9)
  |   <a href="ro818d41.htm">$8D41/36161</a>      Rechenregister 2 *2 bzw. *4 ($cee2)
  |   <a href="ro818d4c.htm">$8D4C/36172</a>      Rechenregister addieren ($ceed)
  |   <a href="ro818d59.htm">$8D59/36185</a>      Feststellen, welcher Kanal schon am laengsten inaktiv ist
  |   <a href="ro818d7d.htm">$8D7D/36221</a>      Puffer wechseln im Zwei-Puffer-Betrieb ($cf1e)
  |   <a href="ro818e37.htm">$8E37/36407</a>      Falls dem Kanal ein Puffer fehlt, einen neuen zuordnen ($cf7b)
  |   <a href="ro818e4d.htm">$8E4D/36429</a>      Aktiven Puffer wechseln ($cf8c)
  |   <a href="ro818e5c.htm">$8E5C/36444</a>      Byte ueber internen Schreibkanal in Puffer schreiben ($cf9b)
  |   <a href="ro818e78.htm">$8E78/36472</a>      Byte in aktuelle Datei schreiben ($cfb7)
  |   <a href="ro818eb1.htm">$8EB1/36529</a>      Byte in Puffer schreiben, Pufferzeiger erhoehen ($cff1)
  |   <a href="ro818ec5.htm">$8EC5/36549</a>      Initialize ($d005)
  |   <a href="ro818edc.htm">$8EDC/36572</a>      Blockheader des Verzeichnisheaders suchen
  |   <a href="ro818f03.htm">$8F03/36611</a>      Partition initialisieren ($d042)
  |   <a href="ro818fd6.htm">$8FD6/36822</a>      Block einlesen und Folgeblock merken ($d09b)
  |   <a href="ro818fea.htm">$8FEA/36842</a>      Block (und ggf. Folgeblock) im 2-Puffer-Modus lesen ($d0af)
  |   <a href="ro818ffe.htm">$8FFE/36862</a>      ???
  |   <a href="ro819027.htm">$9027/36903</a>      Kanal zum Lesen holen und pruefen ($d0eb)
  |   <a href="ro819042.htm">$9042/36930</a>      Kanal zum Schreiben holen und pruefen ($d107)
  |   <a href="ro81905f.htm">$905F/36959</a>      Aktuellen Filetyp holen ($d125)
  |   <a href="ro819069.htm">$9069/36969</a>      Kanal- und Puffernummer holen ($d12f)
  |   <a href="ro819071.htm">$9071/36977</a>      Byte aus aktuellem Puffer holen ($d137)
  |   <a href="ro81909b.htm">$909B/37019</a>      Byte aus aktueller Datei holen ($d156)
  |   <a href="ro819112.htm">$9112/37138</a>      Schreiben eines Bytes in eine Datei im 2-Puffer Modus. ($d19d)
  |   <a href="ro819138.htm">$9138/37176</a>      Erhoehen des aktuellen Pufferzeigers ($d1c6)
  |   <a href="ro819145.htm">$9145/37189</a>      Autoboot bei Warmstart ein/aus
  |   <a href="ro819157.htm">$9157/37207</a>      Kanal oeffnen und entsprechende Zahl Puffer zuordnen ($d1df)
  |   <a href="ro81919e.htm">$919E/37278</a>      Freigeben einer SA ausser der des Kommandokanals; Puffer freigeben ($d227)
  |   <a href="ro8191ce.htm">$91CE/37326</a>      Puffer und dessen Kanalzuordnung freigeben ($d25a)
  |   <a href="ro819204.htm">$9204/37380</a>      Suchen eines freien oder inaktiven Puffers ($d28e)
  |   <a href="ro819228.htm">$9228/37416</a>      Suchen und belegen eines freien Puffers ($d2ba)
  |   <a href="ro81923e.htm">$923E/37438</a>      einen inaktiven Puffer eines Kanals freigeben ($d2da)
  |   <a href="ro819252.htm">$9252/37458</a>      Puffer freigeben                &lt;-- Einsprung
  |   <a href="ro819262.htm">$9262/37474</a>      Kanaele der Sekundaeradressen 1-14 freigeben ($d307)
  |   <a href="ro81926e.htm">$926E/37486</a>      Die SA 0-14 des Laufwerks 0 freigeben
  |   <a href="ro819291.htm">$9291/37521</a>      'Stehlen' eines inaktiven Puffers ($d339)
  |   <a href="ro8192db.htm">$92DB/37595</a>      Freien Kanal suchen ($d37f)
  |   <a href="ro8192f4.htm">$92F4/37620</a>      Byte fuer beliebige SA holen ($d39b)
  |   <a href="ro819303.htm">$9303/37635</a>      Byte aus beliebigem Kanal holen ($d3aa)
  |   <a href="ro819370.htm">$9370/37744</a>      Fehlerkanal auslesen bzw M-R-Befehl ($d414)
  |   <a href="ro8193aa.htm">$93AA/37802</a>      Lesen des naechsten Blocks ($d44d)
  |   <a href="ro8193bd.htm">$93BD/37821</a>      Lesen/Schreiben des aktuellen Puffers ($d460)
  |   <a href="ro8193cf.htm">$93CF/37839</a>      Datei auf internem Lesekanal oeffnen,
  |   <a href="ro8193e0.htm">$93E0/37856</a>      Datei auf internem Schreibkanal oeffnen,
  |   <a href="ro8193e7.htm">$93E7/37863</a>      Neuen Block an das Directory anhaengen ($d48d)
  |   <a href="ro819422.htm">$9422/37922</a>      Pufferzeiger auf bestimmten Wert setzen ($d4c8)
  |   <a href="ro819434.htm">$9434/37940</a>      interne Schreib-/Lesekanaele freigeben ($d4da)
  |   <a href="ro819450.htm">$9450/37968</a>      Holt Byte aus aktuellem Puffer ($d4f6)
  |   <a href="ro819460.htm">$9460/37984</a>      Prueft auf Diskettenwechsel
  |   <a href="ro819471.htm">$9471/38001</a>      T&amp;S auf Gueltigkeit pruefen       ($d506)
  |   <a href="ro8194a8.htm">$94A8/38056</a>      Track und Sektor aus Jobpuffer holen und als aktuelle T&amp;S merken ($d552)
  |   <a href="ro8194b5.htm">$94B5/38069</a>      Auf gueltigen Block (T&amp;S) pruefen ($d55f)
  |   <a href="ro8194cb.htm">$94CB/38091</a>      Meldung fuer falsches Formatkennzeichen ausgeben ($d572)
  |   <a href="ro8194d3.htm">$94D3/38099</a>      Job setzen und Controller aufrufen ($d57a)
  |   <a href="ro8194de.htm">$94DE/38110</a>      Schreib-/Lesejobs pruefen und Durchfuehrung abwarten ($d586)
  |   <a href="ro8194f8.htm">$94F8/38136</a>      Job auf fehlerfreie Durchfuehrung pruefen ($d5a6)
  |   <a href="ro819585.htm">$9585/38277</a>      T&amp;S an DC uebergeben ($d6d0)
  |   <a href="ro819598.htm">$9598/38296</a>      Aufruf des Controllers
  |   <a href="ro8195ab.htm">$95AB/38315</a>      Neue Datei im Directory eintragen ($d6e4)
  |   <a href="ro819678.htm">$9678/38520</a>      Datei mit SA 0-14 oeffnen ($d7b4)
  |   <a href="ro819773.htm">$9773/38771</a>      File zum Schreiben oeffnen ($d8c6)
  |   <a href="ro8197a2.htm">$97A2/38818</a>      Oeffnen eines Files mit Ueberschreiben ($d8f5)
  |   <a href="ro8197ed.htm">$97ED/38893</a>      Zugriffsart feststellen und File zum Lesen oeffnen ($d940)
  |   <a href="ro81984d.htm">$984D/38989</a>      Oeffnen eines Files zum Lesen ($d9a0)
  |   <a href="ro819890.htm">$9890/39056</a>      neues File anlegen und zum Schreiben oeffnen ($d9e3)
  |   <a href="ro819896.htm">$9896/39062</a>      T&amp;S eines Files holen und fuer 'LOAD &quot;*&quot;,8' merken ($d9ef)
  |   <a href="ro8198ab.htm">$98AB/39083</a>      File-Modus oder File-Typ aus Kommandozeile holen ($da09)
  |   <a href="ro8198cc.htm">$98CC/39116</a>      APPEND: Fileende suchen und auf Schreiben umschalten ($da2a)
  |   <a href="ro8198f7.htm">$98F7/39159</a>      Oeffnen des Directory als Basicprogramm ($da55)
  |   <a href="ro81995c.htm">$995C/39260</a>      CLOSE-Routine: aktuelle Sekundaeradresse schliessen ($dac0)
  |   <a href="ro819986.htm">$9986/39302</a>      Alle Dateien schliessen ($daec)
  |   <a href="ro81999f.htm">$999F/39327</a>      Datei schliessen ($db02)
  |   <a href="ro819a2a.htm">$9A2A/39466</a>      letzten Dateiblock abspeichern ($db62)
  |   <a href="ro819a72.htm">$9A72/39538</a>      Eintrag im Directory nach dem Schreiben updaten ($dba5)
  |   <a href="ro819b0d.htm">$9B0D/39693</a>      Kanal zum Lesen suchen
  |   <a href="ro819b9b.htm">$9B9B/39835</a>      Pufferzeiger initialisieren ($dcb6)
  |   <a href="ro819bc3.htm">$9BC3/39875</a>      File zum Schreiben oeffnen ($dcda)
  |   <a href="ro819cca.htm">$9CCA/40138</a>      Byte in aktuellen Side-Sektor schreiben ($dd8d)
  |   <a href="ro819cd3.htm">$9CD3/40147</a>      Dateistatus setzen/loeschen ($dd95)
  |   <a href="ro819ce9.htm">$9CE9/40169</a>      Prueft den Jobcode des aktuellen Puffers auf 'Schreiben' ($ddab)
  |   <a href="ro819cf5.htm">$9CF5/40181</a>      prueft, ob gesuchtes File durch eine SA angesprochen wird ($ddb7)
  |   <a href="ro819d2e.htm">$9D2E/40238</a>      Puffer schreiben, wenn er veraendert wurde ($ddf1)
  |   <a href="ro819d3a.htm">$9D3A/40250</a>      Folgeblock im aktuellen Block eintragen ($ddfd)
  |   <a href="ro819d49.htm">$9D49/40265</a>      T&amp;S des Folgeblocks holen ($de0c)
  |   <a href="ro819d56.htm">$9D56/40278</a>      Blocklaenge des letzten Datenblocks setzen ($de19)
  |   <a href="ro819d69.htm">$9D69/40297</a>      Zeiger auf Anfang des aktiven Puffers setzen ($de2b)
  |   <a href="ro819d79.htm">$9D79/40313</a>      T&amp;S der aktuellen Datei holen ($de3b)
  |   <a href="ro819d8e.htm">$9D8E/40334</a>      Schreib-Lesejobs aufrufen ($de50)
  |   <a href="ro819dce.htm">$9DCE/40398</a>      T&amp;S des Folgeblocks des aktiven Kanals holen
  |   <a href="ro819dde.htm">$9DDE/40414</a>      Pufferinhalte kopieren ($dea5)
  |   <a href="ro819dfa.htm">$9DFA/40442</a>      Puffer mit $00 fuellen ($dec1)
  |   <a href="ro819e0b.htm">$9E0B/40459</a>      Nummer des aktuellen Side-Sektors holen ($ded2)
  |   <a href="ro819e15.htm">$9E15/40469</a>      Side-Sektor-Pufferzeiger auf beliebigen Wert setzen ($dedc)
  |   <a href="ro819e23.htm">$9E23/40483</a>      Pufferzeiger des aktuellen Side-Sektors auf beliebigen
  |   <a href="ro819e32.htm">$9E32/40498</a>      Gruppe anwaehlen, ggf. Side-Sektor laden ($def8)
  |   <a href="ro819e56.htm">$9E56/40534</a>      Side-Sektor lesen/schreiben ($df1b)
  |   <a href="ro819e75.htm">$9E75/40565</a>      Pufferzeiger des Side-Sektors nach $64-$65 holen ($df45)
  |   <a href="ro819e7d.htm">$9E7D/40573</a>      Anzahl der benoetigten Blocks einer REL-Datei berechnen ($df4c)
  |   <a href="ro819e97.htm">$9E97/40599</a>      Anzahl der benoetigten Blocks einer REL-Datei berechnen
  |   <a href="ro819ed3.htm">$9ED3/40659</a>      Feststellen, ob Record existiert und ggf. richtige Gruppe anwaehlen ($df66)
  |   <a href="ro819f11.htm">$9F11/40721</a>      Nummer des aktiven Puffers holen ($df93)
  |   <a href="ro819f1c.htm">$9F1C/40732</a>      Aktiven Puffer pruefen und holen ($df9e)
  |   <a href="ro819f33.htm">$9F33/40755</a>      Pruefen, ob ein Puffer des Kanals nicht belegt ist ($dfb7)
  |   <a href="ro819f3e.htm">$9F3E/40766</a>      einem Kanal einen neuen Puffer zuordnen ($dfc2)
  |   <a href="ro819f4c.htm">$9F4C/40780</a>      naechsten Record holen ($dfd0)
  |   <a href="ro819fbf.htm">$9FBF/40895</a>      ggf. alten Puffer speichern, dann Folgeblock(s) einlesen  ($e03c)
  |   <a href="ro819ffc.htm">$9FFC/40956</a>      Ein Byte in Record-Puffer schreiben ($e07c)
  |   <a href="ro81a033.htm">$A033/41011</a>      Empfangene Daten in Record schreiben ($e0ab)
  |   <a href="ro81a07b.htm">$A07B/41083</a>      Rest eines Records mit $00 auffuellen ($e0f3)
  |   <a href="ro81a08d.htm">$A08D/41101</a>      Flag fuer 'Puffer geaendert' setzen ($e105)
  |   <a href="ro81a09c.htm">$A09C/41116</a>      Flag fuer 'Puffer geaendert' loeschen ($e115)
  |   <a href="ro81a0a6.htm">$A0A6/41126</a>      Byte aus Record-Puffer holen ($e120)
  |   <a href="ro81a0e1.htm">$A0E1/41185</a>      Naechsten Record lesen ($e153)
  |   <a href="ro81a0ec.htm">$A0EC/41196</a>      Abbruch bei Fehler ($e15e)
  |   <a href="ro81a0fd.htm">$A0FD/41213</a>      Letztes benutzte Zeichen im Record suchen ($e16e)
  |   <a href="ro81a15c.htm">$A15C/41308</a>      Letzten Datenblock einer REL-Datei
  |   <a href="ro81a1a1.htm">$A1A1/41377</a>      Position-Befehl ($e207)
  |   <a href="ro81a20d.htm">$A20D/41485</a>      gesuchten Record zur Ausgabe bereitstellen ($e275)
  |   <a href="ro81a235.htm">$A235/41525</a>      benoetigte Datenbloecke  ggf. einlesen ($e29c)
  |   <a href="ro81a298.htm">$A298/41624</a>      Puffer mit leeren Records fuellen ($e2e2)
  |   <a href="ro81a2bc.htm">$A2BC/41660</a>      Position des naechsten Records berechnen ($e304)
  |   <a href="ro81a2d6.htm">$A2D6/41686</a>      Bloecke zu REL-File hinzufuegen ($e31c)
  |   <a href="ro81a438.htm">$A438/42040</a>      Parameter des letzten Records der Datei merken
  |   <a href="ro81a459.htm">$A459/42073</a>      Neuen Side-Sektor zur relativen Datei hinzufuegen ($e31c)
  |   <a href="ro81a547.htm">$A547/42311</a>      Wenn Gruppe voll, dann neue Gruppe anlegen
  |   <a href="ro81a56e.htm">$A56E/42350</a>      Prueft, ob Super-Side-Sektoren verwendet werden, oder nicht
  |   <a href="ro81a574.htm">$A574/42356</a>      Super-Side-Sektor laden
  |   <a href="ro81a5a9.htm">$A5A9/42409</a>      letzte existierende Gruppe ermitteln
  |   <a href="ro81a5c0.htm">$A5C0/42432</a>      Gruppe anwaehlen
  |   <a href="ro81a602.htm">$A602/42498</a>      Fehlermeldungen ($e4fc)
  |   <a href="ro81a7ae.htm">$A7AE/42926</a>      Error-Routine des Controllers ($e60a)
  |   <a href="ro81a7f1.htm">$A7F1/42993</a>      CmdError: Error-Routine des DOS ($e645)
  |   <a href="ro81a83e.htm">$A83E/43070</a>      Byte in Ziffernstring umwandeln ($e69b)
  |   <a href="ro81a862.htm">$A862/43106</a>      Fehlermeldung bereitstellen ($e6bc)
  |   <a href="ro81a8ad.htm">$A8AD/43181</a>      Fehlertext in Puffer schreiben ($e706)
  |   <a href="ro81a926.htm">$A926/43302</a>      Autoboot-Routine
  |   <a href="ro81a938.htm">$A938/43320</a>      JCBMBOOT: Autoboot-Programm aufrufen
  |   <a href="ro81a94c.htm">$A94C/43340</a>      JCBMBOOTRTN: Ruecksprung aus Autoboot-Programm
  |   <a href="ro81a956.htm">$A956/43350</a>      Utility-Loader (&amp;) ($e7a3)
  |   <a href="ro81aa0f.htm">$AA0F/43535</a>      Sprungadressen der Error-Routinen merken
  |   <a href="ro81aa27.htm">$AA27/43559</a>      Sektorversatz einstellen
  |   <a href="ro81aa2d.htm">$AA2D/43565</a>      Anzahl Leseversuche einstellen
  |   <a href="ro81aa33.htm">$AA33/43571</a>      Cache-Verzoegerung einstellen
  |   <a href="ro81aa39.htm">$AA39/43577</a>      ROM-Test
  |   <a href="ro81aa3c.htm">$AA3C/43580</a>      Burst-Befehl $1e: CHGUTL (bei der 1571: $8fe5)
  |   <a href="ro81aaa8.htm">$AAA8/43688</a>      Burst-Memory-Read/Write
  |   <a href="ro81ab09.htm">$AB09/43785</a>      Parameter '0' und '1' auswerten (CHGUTL-Parameter)
  |   <a href="ro81ab1d.htm">$AB1D/43805</a>      ROM-Signatur pruefen (CRC-Test) (bei der 1571: $924e)
  |
  |    BUS-Routinen
  |    [Ein grosses Problem bei der Kommentierung der Bus-Routinen ist, dass die
  |     Leitungen zwischen dem Computer und den Laufwerken low-aktiv sind und
  |     im Computer sogar die Eingangs-Signale nicht wieder zurueckgekippt werden.
  |     Zwischen den verschiedenen ROM-Listings gehen daher die Meinungen
  |     auseiander, was nun unter einem High- und einem Low-Signal zu verstehen
  |     ist. Weil selbst ein im Computer abgeschicktes Hi wieder als Lo empfangen
  |     wird, wird dort deshalb haeufig der am Bus messbare Pegel benutzt. Dagegen
  |     bezeichnen die mir bekannten DOS-Listings ein 1-Bit im Register als Hi
  |     (bei dem die entsprechende Bus-Leitung dann aber Lo ist), weil dann der
  |     'aktive' Pegel mit Hi bezeichnet wird. Wenn also die Ausgaberegister Lo
  |     sind, sind die entsprechenden Treiber inaktiv und stoeren andere Geraete
  |     nicht bei der Datenuebertragung. Das bedeutet aber auch, dass das DATA OUT-
  |     auf Lo gesetzt werden muss, wenn ein 1-Datenbit uebertragen werden soll.
  |     Ich habe mich bei der Kommentierung der BUS-Routinen an das System der
  |     mir bekannten DOS-Listings gehalten und bezeichne ein Signal als Hi, wenn
  |     das entsprechende Register-Bit 1 ist.]
  |
  |   <a href="ro81abcf.htm">$ABCF/43983</a>      ATN-bearbeiten ($e85b; bei der 1571: $80ce)
  |   <a href="ro81ac9d.htm">$AC9D/44189</a>      FSM: DRF (Device Request Fast) Signal senden (bei der 1571: $8199)
  |   <a href="ro81acb6.htm">$ACB6/44214</a>      FSM auf Eingang schalten
  |   <a href="ro81accf.htm">$ACCF/44239</a>      FSM auf Ausgabe schalten
  |   <a href="ro81ace8.htm">$ACE8/44264</a>      DATA OUT auf Lo (die Busleitung wird dadurch Hi)
  |   <a href="ro81acf1.htm">$ACF1/44273</a>      DATA OUT auf Hi (die Busleitung wird dadurch Lo)
  |   <a href="ro81acfa.htm">$ACFA/44282</a>      CLOCK OUT auf Hi (die Busleitung wird dadurch Lo)
  |   <a href="ro81ad03.htm">$AD03/44291</a>      CLOCK OUT auf Lo (die Busleitung wird dadurch Hi)
  |   <a href="ro81ad0c.htm">$AD0C/44300</a>      Bus auslesen und entprellen
  |   <a href="ro81ad15.htm">$AD15/44309</a>      ATN-Modus testen ($ea59; bei der 1571: $ea59)
  |   <a href="ro81ad2f.htm">$AD2F/44335</a>      Kurze Zeit warten (bei der 1571: $a47e)
  |   <a href="ro81ad3c.htm">$AD3C/44348</a>      NMI-Routine ($ff01)
  |   <a href="ro81ad5c.htm">$AD5C/44380</a>      Daten auf seriellen Bus ausgeben ($e909; bei der 1571: $823d)
  |   <a href="ro81ae42.htm">$AE42/44610</a>      Byte vom seriellen Bus holen ($e9c9; bei der 1571: $82c7)
  |   <a href="ro81aeb8.htm">$AEB8/44728</a>      Daten vom seriellem Bus holen ($ea2e; bei der 1571: $8342)
  |   <a href="ro81aed9.htm">$AED9/44761</a>      Ende bei Uebertragungsfehler
  |   <a href="ro81aedf.htm">$AEDF/44767</a>      Busbetrieb beenden
  |   <a href="ro81aeea.htm">$AEEA/44778</a>      JSPINOUT: FSM-Datenrichtung festlegen
  |   <a href="ro81aef2.htm">$AEF2/44786</a>      Fehlerblinken nach Selbsttest ($ea6e)
  |   <a href="ro81af24.htm">$AF24/44836</a>      Reset-Routine ($eaa0)
  |   <a href="ro81afca.htm">$AFCA/45002</a>      Warmstart ($eb22)
  |   <a href="ro81afe9.htm">$AFE9/45033</a>      Dos-Tabellen initialisieren ($eb3a)
  |   <a href="ro81b0b3.htm">$B0B3/45235</a>      Ganze Diskette als Partition setzen
  |   <a href="ro81b0cf.htm">$B0CF/45263</a>      Physikalisches 1581-Diskettenformat festlegen
  |   <a href="ro81b0f0.htm">$B0F0/45296</a>      JIDLE - Hauptleerschleife ($ebe7)
  |   <a href="ro81b15b.htm">$B15B/45403</a>      Cache am Ende der Verzoegerungszeit auf Diskette schreiben
  |   <a href="ro81b17c.htm">$B17C/45436</a>      Directory formatieren und in Ausgabepuffer schreiben ($ec9e)
  |   <a href="ro81b237.htm">$B237/45623</a>      Directoryzeile in Ausgabepuffer kopieren ($ed59)
  |   <a href="ro81b245.htm">$B245/45637</a>      Byte aus Directory holen und zur Ausgabe bereitstellen ($ed67)
  |   <a href="ro81b262.htm">$B262/45666</a>      Validate-Befehl ($ed84)
  |   <a href="ro81b2c7.htm">$B2C7/45767</a>      Blocks eines Files in BAM belegen ($ede5)
  |   <a href="ro81b2ef.htm">$B2EF/45807</a>      naechsten Block einer Partition holen
  |   <a href="ro81b323.htm">$B323/45859</a>      Partition-Parameter aus Verzeichniseintrag holen
  |   <a href="ro81b33c.htm">$B33C/45884</a>      Partition in Bam belegen
  |   <a href="ro81b348.htm">$B348/45896</a>      NEW-Befehl ($ee0d)
  |   <a href="ro81b380.htm">$B380/45952</a>      ???
  |   <a href="ro81b390.htm">$B390/45968</a>      Verzeichnis-Header und BAM anlegen ($ee56)
  |   <a href="ro81b43d.htm">$B43D/46141</a>      BAM-Puffer loeschen ($f005)
  |   <a href="ro81b44a.htm">$B44A/46154</a>      neue BAM erzeugen ($eeb7)
  |   <a href="ro81b515.htm">$B515/46357</a>      Wenn die BAM geaendert wurde, dann
  |   <a href="ro81b546.htm">$B546/46406</a>      Block in Bam freigeben ($ef5f)
  |   <a href="ro81b572.htm">$B572/46450</a>      Block in BAM belegen ($ef93)
  |   <a href="ro81b5b4.htm">$B5B4/46516</a>      BAM-Zeiger auf Eintrag fuer aktuellen Track setzen ($f011)
  |   <a href="ro81b5d8.htm">$B5D8/46552</a>      Pruefen, ob Block $4e im aktuellen Track frei ist ($efd2)
  |   <a href="ro81b5f2.htm">$B5F2/46578</a>      Wenn BAM-Puffer leer, dann BAM einlesen ($f0df)
  |   <a href="ro81b612.htm">$B612/46610</a>      BAM auf Diskette schreiben
  |   <a href="ro81b633.htm">$B633/46643</a>      Verzeichnis-Header in aktuellen Puffer lesen, ggf. BAM lesen
  |   <a href="ro81b643.htm">$B643/46659</a>      T&amp;S und Puffernummer eines Dir-Sektors an DC uebergeben
  |   <a href="ro81b64f.htm">$B64F/46671</a>      BAM-Zeiger auf 1. BAM-Puffer setzen ($ef3a)
  |   <a href="ro81b65b.htm">$B65B/46683</a>      Anzahl freier Blocks zur Ausgabe bereitstellen ($ef4d)
  |   <a href="ro81b668.htm">$B668/46696</a>      Folgeblock fuer Datei suchen ($f11e)
  |   <a href="ro81b6ed.htm">$B6ED/46829</a>      Startblock einer neuen Datei suchen ($f1a9)
  |   <a href="ro81b746.htm">$B746/46918</a>      naechsten freien Block im aktuellen Track suchen ($f1fa)
  |   <a href="ro81b75e.htm">$B75E/46942</a>      Prueft, ob im aktuellen Track die Anzahl freier Blocks stimmt. ($f220)
  |   <a href="ro81b781.htm">$B781/46977</a>      Partition-Befehl
  |   <a href="ro81b811.htm">$B811/47121</a>      Pruefen, ob alle Blocks der Partition vor dem Anlegen noch frei sind
  |   <a href="ro81b851.htm">$B851/47185</a>      Partition-Namen holen
  |   <a href="ro81b85f.htm">$B85F/47199</a>      Parameter fuer die Partitionerstellung holen
  |   <a href="ro81b88d.htm">$B88D/47245</a>      Neuen Bereich anlegen
  |   <a href="ro81b8d2.htm">$B8D2/47314</a>      Burst-Befehl $1f: Fastload (bei der 1571: $9080)
  |   <a href="ro81b9d3.htm">$B9D3/47571</a>      ERROR: Controller-Error-Routine des Burst-Fastloads
  |   <a href="ro81b9df.htm">$B9DF/47583</a>      CMDERR: Fehler-Routine des Burst-Fastloads
  |   <a href="ro81b9ec.htm">$B9EC/47596</a>      Fehlermeldung ausgeben (bei der 1571: $91ad)
  |   <a href="ro81b9fb.htm">$B9FB/47611</a>      #$02 auf FSM-Bus ausgeben (File not found), TXA
  |   <a href="ro81ba06.htm">$BA06/47622</a>      Filenamen nach Drivenummer durchsuchen
  |   <a href="ro81ba40.htm">$BA40/47680</a>      Byte auf FSM-Bus ausgeben (bei der 1571: $9228)
  |   <a href="ro81ba64.htm">$BA64/47716</a>      Fehlerbehandlung fuer Burst-Fastload setzen
  |   <a href="ro81ba7c.htm">$BA7C/47740</a>      Sprungvektoren der Fehlerbehandlung retten
  |   <a href="ro81ba95.htm">$BA95/47765</a>      Sprungvektoren der Fehlerbehandlung zurueckschreiben
  |   <a href="ro81baae.htm">$BAAE/47790</a>      Burst-Befehl: Read mit logischen Blockangaben (bei der 1571: $83a4)
  |   <a href="ro81baf7.htm">$BAF7/47863</a>      Burst-Status uebermitteln (bei der 1571: $837c)
  |   <a href="ro81bafc.htm">$BAFC/47868</a>      Status in a setzen und uebermitteln (bei der 1571: $8381)
  |   <a href="ro81bb11.htm">$BB11/47889</a>      Burst-Befehle $00,$10: Read (bei der 1571: $8371)
  |   <a href="ro81bb74.htm">$BB74/47988</a>      Burst-Befehl: Write mit logischen Blockangaben
  |   <a href="ro81bbf6.htm">$BBF6/48118</a>      Burststatus bei Schreibfehlern ausgeben
  |   <a href="ro81bc01.htm">$BC01/48129</a>      Burst-Befehle $02,$12: Write (bei der 1571: $83ec)
  |   <a href="ro81bcb2.htm">$BCB2/48306</a>      Burst-Befehle $04,$14: Inquire Disk (bei der 1571: $848b)
  |   <a href="ro81bd0a.htm">$BD0A/48394</a>      ???
  |   <a href="ro81bd12.htm">$BD12/48402</a>      Burst-Befehle $06,$07,$16,$17: Format (bei der 1571: $84b7)
  |   <a href="ro81bdfc.htm">$BDFC/48636</a>      Burst-Befehle $08,$09: (n.v.) (bei der 1571: $85a5)
  |   <a href="ro81be06.htm">$BE06/48646</a>      Burst-Befehle $0a,$1a: Query Disk Format (bei der 1571: $8517)
  |   <a href="ro81bebb.htm">$BEBB/48827</a>      Burst-Befehl $0c: Inquire Status (bei der 1571: $856b)
  |   <a href="ro81bef8.htm">$BEF8/48888</a>      Burst-Befehle $0e,$0f: (n.v.)
  |   <a href="ro81bf02.htm">$BF02/48898</a>      Burst-Befehle $1c,$1d: Dump Cache
  |   <a href="ro81bf44.htm">$BF44/48964</a>      Kopf ggf. auf die angegebene Spur setzen (bei der 1571: $891b)
  |   <a href="ro81bf5a.htm">$BF5A/48986</a>      Burst-Status senden, wenn gerade Daten vom Computer empfangen werden
  |   <a href="ro81bf66.htm">$BF66/48998</a>      Burst-Status setzen
  |   <a href="ro81bf83.htm">$BF83/49027</a>      FSM: Byte ausgeben (bei der 1571: $9228)
  |   <a href="ro81bfab.htm">$BFAB/49067</a>      Statusbyte ausgeben
  |   <a href="ro81bfb0.htm">$BFB0/49072</a>      Job ausfuehren und ggf. bei Fehlern mehrmals versuchen (bei der 1571: $864b)
  |   <a href="ro81bfe3.htm">$BFE3/49123</a>      Cachepuffer auf Diskette schreiben
  |   <a href="ro81c026.htm">$C026/49190</a>      FSM: Wartet, bis naechstes Byte gesendet werden soll (bei der 1571: $86a0)
  |   <a href="ro81c040.htm">$C040/49216</a>      physikalischen Folgesektor holen (bei der 1571: $886c)
  |   <a href="ro81c07a.htm">$C07A/49274</a>      logischen Folgesektor holen (bei der 1571: $886c)
  |   <a href="ro81c097.htm">$C097/49303</a>      Groesste/kleinste Sektornummer suchen (bei der 1571: $8961)
  |   <a href="ro81c0be.htm">$C0BE/49342</a>      JLCC: Controller-Routine
  |   <a href="ro81c163.htm">$C163/49507</a>      Tabellen des Controller-Programms
  |   <a href="ro81c390.htm">$C390/50064</a>      JOB $84: MOTON_DV
  |   <a href="ro81c393.htm">$C393/50067</a>      JOB $86: MOTOFF_DV
  |   <a href="ro81c396.htm">$C396/50070</a>      JOB $88: MOTONI_DV
  |   <a href="ro81c3a9.htm">$C3A9/50089</a>      JOB $8a: MOTOFFI_DV
  |   <a href="ro81c3af.htm">$C3AF/50095</a>      JOB $8c: SEEK_DV
  |   <a href="ro81c3bb.htm">$C3BB/50107</a>      JOB $8e: FORMAT_DV
  |   <a href="ro81c3d6.htm">$C3D6/50134</a>      Spur formatieren
  |   <a href="ro81c546.htm">$C546/50502</a>      LED-Routinen des Controller-Programms
  |   <a href="ro81c56a.htm">$C56A/50538</a>      JOB $9c: SIDE_DV
  |   <a href="ro81c589.htm">$C589/50569</a>      JOB $9e: BUFMOVE_DV
  |   <a href="ro81c5ac.htm">$C5AC/50604</a>      JOB $a2: TRKWRT_DV
  |   <a href="ro81c5af.htm">$C5AF/50607</a>      Patches
  |   <a href="ro81c600.htm">$C600/50688</a>      Cachepuffer auf Diskette schreiben
  |   <a href="ro81c6d7.htm">$C6D7/50903</a>      JOBs $92, $a8: DISKIN_DV, PSEEK_DV
  |   <a href="ro81c700.htm">$C700/50944</a>      JOB $a6: SP_WRITE
  |   <a href="ro81c800.htm">$C800/51200</a>      JOB $a4: SP_READ
  |   <a href="ro81c900.htm">$C900/51456</a>      JOBs $80, $90: READ_DV, WRITE_DV
  |   <a href="ro81c9e1.htm">$C9E1/51681</a>      Job $a0: WRTVER_DV
  |   <a href="ro81ca00.htm">$CA00/51712</a>      Spur mit Cachedaten vergleichen
  |   <a href="ro81cadc.htm">$CADC/51932</a>      Verify-Error ausgeben
  |   <a href="ro81cae4.htm">$CAE4/51940</a>      JOB $b8: SEEKPHD_DV
  |   <a href="ro81cb0f.htm">$CB0F/51983</a>      JOB $c0: RESTORE_DV
  |   <a href="ro81cb26.htm">$CB26/52006</a>      JOBs $d0, $e0: JUMPC_DV, EXBUF_DV: Programm im Jobpuffer ausfuehren
  |   <a href="ro81cb35.htm">$CB35/52021</a>      JOB $f0: FORMATDK_DV
  |   <a href="ro81cb76.htm">$CB76/52086</a>      JOB $b6: DETWP_DV
  |   <a href="ro81cb85.htm">$CB85/52101</a>      Job-Fehlermeldungen
  |   <a href="ro81cb8d.htm">$CB8D/52109</a>      Prueft, ob Sektor in Cachepuffer passt, Cachezeiger setzen
  |   <a href="ro81cb9f.htm">$CB9F/52127</a>      Timer setzen und starten
  |   <a href="ro81cbb1.htm">$CBB1/52145</a>      Laufwerksmotor ein-/ausschalten
  |   <a href="ro81cbc3.htm">$CBC3/52163</a>      Drive LED ein-/ausschalten
  |   <a href="ro81cbd5.htm">$CBD5/52181</a>      Warten ... .  .   .zzz . .z ..
  |   <a href="ro81cbec.htm">$CBEC/52204</a>      Auf Controller-Ready warten
  |   <a href="ro81cbf4.htm">$CBF4/52212</a>      Kommandobyte in Controller schreiben
  |   <a href="ro81cd00.htm">$CD00/52480</a>      Blockheader lesen
  |   <a href="ro81cd3f.htm">$CD3F/52543</a>      Controller-Status pruefen
  |   <a href="ro81cd63.htm">$CD63/52579</a>      Wenn der Motor aus war, Motor einschalten und Verzoegerungszeit einstellen
  |   <a href="ro81cd7b.htm">$CD7B/52603</a>      Anlaufvorgang ueberwachen
  |   <a href="ro81cdbc.htm">$CDBC/52668</a>      Abfragen, ob Diskette eingelegt ist
  |   <a href="ro81cdcc.htm">$CDCC/52684</a>      Jobauftrag beenden, alle Jobs nochmal pruefen
  |   <a href="ro81cde2.htm">$CDE2/52706</a>      Ruecksprung von Jobroutine, den selben Job nochmal pruefen
  |   <a href="ro81ce00.htm">$CE00/52736</a>      Hauptsteuerroutine des Controllers
  |   <a href="ro81ce71.htm">$CE71/52849</a>      Schrittmotor ansteuern
  |   <a href="ro81cea4.htm">$CEA4/52900</a>      Daten zwischen Cache und Puffer transferieren
  |   <a href="ro81cedc.htm">$CEDC/52956</a>      JTRANS_TS: logisches in physikalisches Format umwandeln
  |   <a href="ro81cf51.htm">$CF51/53073</a>      Schreiben/Lesen mit Cache-Daten
  |   <a href="ro81cfa6.htm">$CFA6/53158</a>      Blockheader lesen
  |   <a href="ro81cfb7.htm">$CFB7/53175</a>      Copy-Zeiger auf Cachepuffer-Anfang setzen
  |   <a href="ro81cfc0.htm">$CFC0/53184</a>      Seite auswaehlen
  |   <a href="ro81cfd1.htm">$CFD1/53201</a>      Controller initialisieren
  |   <a href="ro81cfe3.htm">$CFE3/53219</a>      Precompensation ein/ausschalten
  |   <a href="ro81d00d.htm">$D00D/53261</a>      Daten vom Puffer in den Cache kopieren
  |   <a href="ro81d549.htm">$D549/54601</a>      Daten vom Cache in den Puffer kopieren
  |   <a href="ro81da63.htm">$DA63/55907</a>      CRC-Pruefsumme des Blockheaders testen
  |   <a href="ro81dafd.htm">$DAFD/56061</a>      IRQ-Routine
  |   <a href="ro81dbc7.htm">$DBC7/56263</a>      Patches
  |   <a href="ro81ff00.htm">$FF00/65280</a>      Sprungvektoren
  |   <a href="ro81ff75.htm">$FF75/65397</a>      Tabelle der DOS-Funktionen
  |
  +------------------------------------------------------------------------

</pre></td></tr></table></center></body></html>
